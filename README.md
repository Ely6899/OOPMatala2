# OOPMatala2
Second task of the OOP course. This task is about threads and multi-threading.
This task is split into 2 parts.<br >
***The first part*** is about benchmarking a specific problem using a regular algorithm against `threads` and a `thread-pool` by measuring
the run times of each algorithm.<br >
Results will be provided with explanations for the reasons behind them.<br >
***The second part*** is about implementing a custom `thread-pool` API which is able to sort the tasks given to it by the priority of each task.<br >
The implementation of this API relies on the existing `thread-pool` Java implementations.<br >
Both parts are provided with relevant tests.
## Task structure
Source files can be located in those paths:<br >
***Part 1***:<br >
> src/Ex2P1

***Part 2***:<br >
>src/Ex2P2

Part 1 sourse file names and their purpose:
- `Ex2_1.java` -> contains all relevant function implementations.
- `CounterThread.java` -> A class which acts as a custom `thread` for the threading algorithm.
- `ThreadPoolHelper.java` -> A class which acts as the relevant `callable` class for the thread-pool algorithm.

***Part 1 diagram***
![First part diagram](https://github.com/Ely6899/OOPMatala2/blob/master/src/Ex2P1/Part1Diagram.png?raw=true)

Part 2 source file names and their purpose:
- `TaskType.java` -> enum class which represents the `TaskType` and the priority of the `Task` instance.
- `Task.java` -> A generic class which holds `callable` functions, but with the addition of priorities represented in `TaskType`.
Also contains an inner class called `TaskComparator` which acts as a `comparator` for `Task` instances.
- `CustomExecutor.java` -> The custom thread-pool asked to be implemented. Extends the existing java `ThreadPoolExecutor` class.
- `TaskReqAdapter.java` -> A class which is a part of the ***adapter design pattern*** for `CustomExecutor`. Used for adapting the tasks given to the
executor to a valid `runnable`. 

***Part 2 diagram****
![Second part diagram](https://github.com/Ely6899/OOPMatala2/blob/master/src/Ex2P2/DiagramPart2.png?raw=true)


## Explanation of implementation
### Part 1
Part 1 is about generating a given amount of text files with a pseudo randomized amount of lines in each file(dictated by a `seed` value) 
and bounded by the `bound` parameter given.
After generating the files, we activate 3 different algorithms which do the same thing: count the sum of rows of all the files generated by the file
generation function called `createTextFiles()`.<br >
All the different calculations are done in the `Ex2_1.java` class. It mainly holds 3 functions that act as row counters for all files generated:
- `getNumOfLines()` -> Counts the line sum using a simple loop which iterates on each file.
- `getNumOfLinesThreads()` -> Counts the line sum using threads.
- `getNumOfLinesThreadPool()` -> Counts the line sum using a thread-pool.

And each file has its rows counted by the function `readFileAndCountRows()`.<br >
In additon, the amount of threads in both thread algorithms is the same as the amount of files generated.<br >
However, the main idea behind the part was about measuring the run times between the 3 methods: The regular loop algorithm, the thread algorithm
and the thread-pool algorithm. The measurments are dependent on the number of files generated and allowed bound of them.
***Measurement data table***
![First part measurement data](https://github.com/Ely6899/OOPMatala2/blob/master/src/Ex2P1/Part%201%20data.png?raw=true)
***NOTE 1***: Data was measured with seed value of 10.<br >
***NOTE 2***: All run-times were measured in milliseconds(ms). <br >
***NOTE 3***: The run-times ***do not*** include the file generation runtime and file deletion runtime.

***Conclusions from the measurements:***<br >
The first intuitive conclusion is that the bigger our file count, and the bigger `bound`, general run-times are higher. The second is that the regular
algorithm increases in run-time in an intuitive and expected manner in relation to the amount of files and the bound. Meaning, that the more files we
generate, and the more rows we allow each file to be written, the more time it takes the loop to count each file and retrieve the line sum.<br >
<br >
However, things get less intuitive when we look at the relative run-times of each algorithm, and the changes of the run times in the `threads` algorithm
and `thread-pool` algorithm.<br >
1. We can notice is that the `threads` and `thread-pool` algorithms only beat the regular algorithm only when `bound` is big enough.
Meaning, that if the bound is not big enough, the regular algorithm will win in terms of run-time, regardess of file count.
2. There is an inconsistency with which ever `thread` algorithm wins in run-time when we increase the `bound`.
3. `Threads` algorithm general run-time seems to increase as expected, however, the `thread-pool` general run-time shows exponential
run-time increase the more files we generate.
4. `Threads` and `thread-pool` general run-time change when we change the `bound` also tends to show inconsistency.
5. In general, the `threads` algorithm tends to win almost every file count measurement, whenever we increase the bound, when `thread-pool` wins rarely,
and sometimes stays the same as the threads in run-time.
6. In general, the `threads` algorithms always wins as long as the `bound` of the files generated is big enough(in an off written test, that `bound`
value was found to be somewhere around 5000).

***Possible explanations for the results***<br >
1. The general `thread` algorithms run-time inconsistencies might depend on the computer CPU architechture and available cores for the `JVM`.
2. Since in lower `bounds` the regular algorithm runs relatively fast, it outpaces the `thread` creation times of the `threads` and `thread-pool`
algorithms. Therefore, in higher `bounds`, the `threads` and `thread-pool` are able to efficiently split the work the bigger the files are, which results
in outpacing the regular algorithm in general, from a specific bound. Meaning, that the regular algorithm is so fast on low `bounds`, that it even
outpaces the `thread` creation time in both `thread` and `thread-pool` algorithm.
3. An important part of the `thread-pool` algorithm is that it works using a java built-in `ThreadPoolExecutor` instance called `FixedThreadPool`.
It is a special `ThreadPoolExecutor` which defines the core bounds to be fixed with the ammount of cores given to it to be both the lower and upper
bounds when it comes to core amounts. Meaning, that if all `threads` are active, new tasks will wait in the queue. However, since it was requested
to specify the `nThreads` parameter to be the same as the number of generated files, then we can assume that in lower bounds, with the same reasoning as
the second reason, the more files we generate, the more time it takes the `thread-pool` to run. But in higher bounds, because all the threads will be
active, the regular algorithm can't outpace the `FixedThreadPool` concurrency of calculations. 
4. The `threads` algorithm generally performs faster, ***most of the time*** because creating a single `thread` is generally faster then generating
an entire set of `threads` as a part of a `thread-pool`, which takes even more parameters except the number of `threads` in its constructor. Which might
explain general faster `threads` run-time then `thread-pool.
5. There is an element of pseudo-randomness in the algorithms, since creation and execution of `threads` in the background is not in our control,
but in the control of the OS and the CPU. Which can explain the inconsistency of run-times.

***IN GENERAL:*** In low `bounds`(<5000) the regular loop algorithms runs faster. In high `bounds`(>5000) the `threads` and `thread-pool` algorithms
run faster. The number of files play a role in the general run-time of all the algorithms.

### Part 2
As stated in the beginning of the document, the second part is about using an existing `ThreadPoolExecutor` Java implementation and modifying it 
to perform different tasks(which we define), while considering the `priority` of each `Task` which is defined by the `TaskType` enum.<br >
The newly created `thread-pool` is called `CustomExecutor`.<br >
The general implementation also uses primarily 2 design patterns which help tackle several problem along the way of implementing the new API.<br >
- The ***Factory Method*** design pattern.
- The ***Adapter*** design pattern.

***The general explanation will be explained per source file***
#### `TaskType.java`
An `enum` class, which holds 3 values:
- `COMPUTATIONAL(1)`
- `IO(2)`
- `OTHER(3)`

The values near each `enum` represent the priority value of it ***(lower number is higher priority)***

#### `Task.java`
A class which implements the `callable` interface, which holds a `callable` function, and a value derived from the function. However, in addition to it, it also holds a special `TaskType` instance, which dictates how important that `Task` instance is, which is unlike the regular `callable` instances used for the Java built-in `ThreadPoolExecutor`. This is important because we will use the `TaskType` `priority value` to compare between each `Task` instance, so that the more important tasks(which have a lower numerical `priority value`) are sent to our `CustomExecutor` before the least important ones.<br >
In addition, this class is defined to be `generic`, and the type is defined by the value the `callable` function returns. Therefore, `Task` can
hold any `Type` we want.<br >
The holding of values is done in the `Future` instance defined in `Task`.<br >
`Future` is a `generic` built in Java class which acts as a value holder when the `callable` fuction was submitted to the `ThreadPoolExecutor`.
Getting its value is defined by calling the `get()` function, which is also defined in our `Task` class for that purpose.<br >
This class also uses the `Factory method` design pattern. The implementation of it is evident in the static function `createTask`.<br >
The `Task` instances can be compared because of the implementation of `Comparator<Task<T>>`, by overriding the `compare()` function.<br >

#### `CustomExecutor.java`
The custom `thread-pool` we were required to implement. It extends the `ThreadPoolExecutor` class, which allows us to inherit the constructor of
`ThreadPoolExecutor` and define it with our custom settings that were required.<br >
The main change is in the `PriorityQueue` that we pass to `ThreadPoolExecutor`. We want the `PriorityQueue`, which was passed as
`PriorityBlockingQueue` to sort the tasks passed to it by the `priority value` of each task. This is possible because of the implementation of the ***inner
class*** `TaskComparator`, which handles the sorting of the `PriorityBlockingQueue` by passing a new `TaskComparator` instance to it.<br >
It was also required to implement our own `submit()` function, which acts exactly the same as the original built in Java `submit()`.
However, a problem we encountered was that because `Task` is a `callable` class, the `ThreadPoolExecutor` refused to recieve a `non-runnable` class.
To solve this, we adapt the given task to a `TaskReqAdapter` class, which handles adapting the `Task` instance to be `runnable`, without the
loss of the original `Task` functionality. This is the class which represents the ***Adapter*** design pattern in our implemention.<br >
Finally, it also has a function called `getCurrentMax()`, which returns the highest ***numerical*** priority which is currently in the
`PriorityBlockingQueue`. It's calculation is done using the `BeforeExecute()` function and is saved in the `maxPriority` field.





