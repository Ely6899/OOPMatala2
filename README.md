# OOPMatala2
Second task of the OOP course. This task is about threads and multi-threading.
This task is split into 2 parts.<br >
***The first part*** is about benchmarking a specific problem using a regular algorithm against threads and a thread-pool by measuring
the run times of each algorithm.<br >
Results will be provided with explanations for the reasons behind them.<br >
***The second part*** is about implementing a custom thread-pool API which is able to sort the tasks given to it by the priority of each task.<br >
The implementation of this API relies on the existing thread-pool Java implementations.<br >
Both parts are provided with relevant tests.
## Task structure
Source files can be located in those paths:<br >
***Part 1***:<br >
> src/Ex2P1

***Part 2***:<br >
>src/Ex2P2

Part 1 sourse file names and their purpose:
- Ex2_1.java -> contains all relevant function implementations.
- CounterThread.java -> A class which acts as a custom thread for the threading algorithm.
- ThreadPoolHelper.java -> A class which acts as the relevant callable class for the thread-pool algorithm.

***Part 1 diagram***
![First part diagram](https://github.com/Ely6899/OOPMatala2/blob/master/src/Ex2P1/Part1Diagram.png?raw=true)

Part 2 source file names and their purpose:
- TaskType.java -> enum class which represents the task type and the priority of the task.
- Task.java -> A generic class which holds collable functions, but with the addition of priorities represented in TaskType.
Also contains an inner class called TaskComparator which acts as a comparator for Task instances.
- CustomExecutor.java -> The custom thread-pool asked to be implemented. Extends the existing java ThreadPoolExecutor class.

***Part 2 diagram****
![Second part diagram](https://github.com/Ely6899/OOPMatala2/blob/master/src/Ex2P2/DiagramPart2.png?raw=true)


## Explanation of implementation
### Part 1
Part 1 is about generating a given amount of text files with a pseudo randomized amount of lines in each file(dictated by a seed value) 
and bounded by the bound parameter given.
After generating the files, we activate 3 different algorithms which do the same thing: count the sum of rows of all the files generated by the file
generation function called createTextFiles().<br >
In additon, the amount of threads in both thread algorithms is the same as the amount of files generated.<br >
However, the main idea behind the part was about measuring the run times between the 3 methods: The regular loop algorithm, the thread algorithm
and the thread-pool algorithm. The measurments are dependent on the number of files generated and allowed bound of them.
***Measurement data table***
![First part measurement data](https://github.com/Ely6899/OOPMatala2/blob/master/src/Ex2P1/Part%201%20data.png?raw=true)
***NOTE 1***: data was measured with seed value of 10.<br >
***NOTE 2***: All run-times were measured in milliseconds(ms). <br >
***NOTE 3***: The run-times ***do not*** include the file generation runtime and file deletion runtime.

***Conclusions from the measurements:***<br >
The first intuitive conclusion is that the bigger our file count, and the bigger bound, general run-times are higher. The second is that the regular
algorithm increases in run-time in an intuitive and expected manner in relation to the amount of files and the bound. Meaning, that the more files we
generate, and the more rows we allow each file to be written, the more time it takes the loop to count each file and retrieve the line sum.<br >
<br >
However, things get less intuitive when we look at the relative run-times of each algorithm, and the changes of the run times in the threads algorithm
and thread-pool algorithm.<br >
1. We can notice is that the thread and thread-pool algorithm only beat the regular algorithm only when bound is big enough.
Meaning, that if the bound is not big enough, the regular algorithm will win in terms of run-time, regardess of file count.
2. There is an inconsistency with which ever thread algorithm wins in run-time when we increase the bound.
3. Thread algorithm general run-time seems to increase as expected, however, the thread-pool general run-time shows exponential
run-time increase the more files we generate.
4. Threads and thread-pool general run-time change when we change the bound also tends to show inconsistency.
5. In general, the threads algorithm tends to win almost every file count measurement, whenever we increase the bound, when thread-pool wins rarely,
and sometimes stays the same as the threads in run-time.
6. In general, the threads algorithms always win as long as the bound of the files generated is big enough(in an off written test, that bound
value was found to be somewhere around 5000).

***Possible explanations for the results***<br >
1. The general thread algorithms run-time inconsistencies might depend on the computer CPU architechture and available cores of the JVM.
2. Since in lower bounds the regular algorithm runs relatively fast, it outpaces the thread creation times of the threads and thread-pool
algorithms. Therefore, in higher bounds, the threads and thread-pool are able to efficiently split the work the bigger the files are, which results
in outpacing the regular algorithm in general, from a specific bound.
3. The in-built java thread-pool logic is that as long as the task queue it has is not filled, a new thread in the thread-pool wont start
, and because that queue is so big, the thread pool will run relatively slow and it will requrire much more data if it will open a new thread.
In contrast, threads dont have this kind of limitaion, therefore, it might explain the regular threads usually winning the thread-pool
in big eniugh bounds.



